1) custom rust structs shared between client / server (Shared Rust Structs)
1.1) shared struct: variable size (contains vec), read only
1.2) shared struct: variable size (contains vec), mutable
1.3) shared struct: fixed-size structured state, read only
1.4) shared struct: fixed-size structured state, mutable in place
2) merge into persistent state - incremental state evolution
2.1) merge into persistent state - incremental state evolution - (table, dynamic)
2.2) merge into persistent state - incremental state evolution - (table, fixed)
2.3) merge into persistent state - incremental state evolution - (struct, fixed)
2.4) merge into persistent state - incremental state evolution - (struct, dyn)
3) Replace entire client DataFrame (full refresh)
3.1) replace DataFrame: different number of rows in the old and new DataFrame
3.2) replace DataFrame: same fixed number of rows in old and new DataFrame
4) Append new data to an existing DataFrame (incremental growth)
4.1) Append to DataFrame: Small frequent streaming appends (real-time updates)
4.2) Append to DataFrame: Append with batching to avoid fragmentation (Arrow Builders hybrid)
4.5) Insert into DataFrame
5.1) Downloads
5.2) Chunked streaming assembly
5.3) HTTP fetch streaming + direct-to-WASM memory
5.4) Compression / Encoding Strategy Patterns
6.1) Typed request struct (field-based queries)
8) Rust/WASM to JS, return data
8.1) Client-side slice for virtualization (visible rows only)
8.3) Rust passes/copies values directly to JS
8.4) Rust passes/copies values directly to HTML
9) Rust/WASM to JS, UI presentation
9.1) Rust/WASM renders directly
9.2) Rust/WASM returns minimal "signals" to JS
9.3) Island architecture component
10) JS UI to Rust/WASM Request Patterns
10.1) JS UI to Rust/WASM Request Patterns
10) Data Lifetime & Buffer Semantics, memory model
10.1) Snapshot buffer lifetime model
10.2) Mutable buffer repurposing
11) Initial load
11.1) Initial page load: "bootstrap snapshot"
11.2) initial page load, w/ early render
